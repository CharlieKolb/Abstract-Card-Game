from dataclasses import dataclass
import json
import os
import pprint

pp = pprint.PrettyPrinter()

path = os.path.dirname(os.path.realpath(__file__))
data = json.loads("\n".join(open(os.path.join(path, "reactions.json")).readlines()))


@dataclass
class Entry:
    var_name: str
    var_type: str

@dataclass
class Payload:
    name: str
    entries: list[Entry]

@dataclass
class Reaction:
    name: str
    payloads: list[Payload]


def make_entries(json_data):
    res = []
    for k, v in json_data.items():
        res.append(Entry(k, v))
    return res

def make_payloads(json_data):
    res = {}
    for name, data in json_data.items():
        res[name] = Payload(name, make_entries(data))
    return res

def make_reactions(payloads, reactions_data, name_path = ""):
    res = {}
    for k, v in reactions_data.items():
        if type(v) == type(dict()):
            res[k] = make_reactions(payloads, v, name_path + f"{k}.")
        else:
            if type(v) == str:
                v = [v]
            res[k] = Reaction(f"{name_path}{k}", [payloads[x] for x in sorted(v)])
    return res


def verify_payloads(payloads: list[Payload]):
    seen_var_names = dict()
    for pl in payloads:
        for entry in pl.entries:
            if entry.var_name in seen_var_names:
                print(f"error: duplicate variable name '{entry.var_name}', first defined in payload '{seen_var_names[entry.var_name]}', duplicated in '{pl.name}'")
                exit(1)
            seen_var_names[entry.var_name] = pl.name

payloads = make_payloads(data["payloads"])
verify_payloads(payloads.values())
# todo: verify that paylodas all have different var names

reactions = make_reactions(payloads, data["reactions"])


# pp.pprint(payloads)
# pp.pprint(reactions)


def make_payload_str(payload: Payload, indent):
    res = []
    res.append(" " * indent + f"// Payload `{payload.name}`")
    for entry in payload.entries:
        res.append(" " * indent + f"public {entry.var_type} {entry.var_name};")
    return res

def make_constructor_parameters(payload: Payload):
    res = []
    res.append(f"// Payload `{payload.name}`")
    for entry in payload.entries:
        res.append(f"{entry.var_type} {entry.var_name}")
    return res


def make_constructor(name: str, payloads: list[Payload], indent: int) -> str:
    res = []
    payload_list = []
    for p in payloads:
        payload_list += make_constructor_parameters(p)
    res.append(" " * indent + f"public {name}(")
    res.append(",\n".join(" " * (indent + 4) + x for x in ["GS gameState"] + payload_list))

    res.append(" " * indent + f') : base(gameState, {name}.Key) {{')

    payload_var_names = [y.split(" ")[1] for y in payload_list]
    payload_assignments = [f"this.{name} = {name};" if not line.startswith("//") else line for line, name in zip(payload_list, payload_var_names)]
    res.append("\n".join(" " * (indent + 4) + x for x in payload_assignments))


    res.append(" " * indent + "}")

    return res


def make_invokable(name: str, reaction: Reaction, indent: int):
    res = []
    res.append(" " * indent + f"public class {name} : Invokable {{")
    res.append(" " * (indent + 4) + f'public new static string Key = "{reaction.name}";')
    for pl in sorted(reaction.payloads, key=lambda x: x.name):
        res += make_payload_str(pl, indent + 4)
    res += make_constructor(name, reaction.payloads, indent + 4)

    res.append(" " * indent + "}")
    return res




def make_class(reaction_entry, indent = 0):
    res = []
    for k, v in sorted(reaction_entry.items(), key=lambda x: x[0]):
        k = k.upper()
        if type(v) == Reaction:
            res += make_invokable(k, v, indent)
        else:
            res.append(" " * indent + f"public class {k} " + "{")
            res += make_class(v, indent + 4)
            res.append(" " * indent + "}")
    return res

def make_reaction_string(reactions):
    res = []
    res.append(f"// AUTOGENERATED BY Assets/Scripts/Logic/reactions/generate.py")
    res.append("public class Reactions {")

    res += make_class(reactions, 4)

    res.append("}")
    return res


with open("Reactions.cs", "w+") as f:
    f.write("\n".join(make_reaction_string(reactions)))